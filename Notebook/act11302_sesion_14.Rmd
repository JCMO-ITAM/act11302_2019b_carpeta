---
title: "Sesion 14 - Diversificacion via mezclas"
author:
-  Juan Carlos Martínez-Ovando
date: "Otoño 2019"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 3
    number_sections: yes
    self_contained: yes
    theme: cerulean # cosmo
    highlight: textmate
fig_align: "center"
fig_width: 18

header-includes:
    - \usepackage[most]{tcolorbox}
    - \usepackage{mathtools}
    - \definecolor{light-yellow}{rgb}{1, 0.95, 0.7}
    - \newtcolorbox{myquote}{colback=light-yellow,grow to right by=-10mm,grow to left by=-10mm, boxrule=0pt,boxsep=0pt,breakable}
    - \newcommand{\todo}[1]{\begin{myquote} \textbf{TODO:} \emph{#1} \end{myquote}}

---

\newcommand{\WiD}{\operatorname{\text{Wi}}}
\newcommand{\WeD}{\operatorname{\text{We}}}
\newcommand{\WeNormD}{\operatorname{\text{We-N}}}
\newcommand{\ExpD}{\operatorname{\text{Exp}}}
\newcommand{\BeD}{\operatorname{\text{Be}}}
\newcommand{\GeoD}{\operatorname{\text{Geo}}}
\newcommand{\StD}{\operatorname{\text{St}}}
\newcommand{\NormD}{\operatorname{\text{N}}}
\newcommand{\GaD}{\operatorname{\text{Ga}}}
\newcommand{\UniD}{\operatorname{\text{U}}}
\newcommand{\DirD}{\operatorname{\text{Dir}}}
\newcommand{\IG}{\operatorname{\text{InG}}}
\newcommand{\IncGa}{\operatorname{\text{IGa}}}
\newcommand{\IGa}{\operatorname{\text{InGa}}}
\newcommand{\PoD}{\operatorname{\text{Po}}}
\newcommand{\BS}{\operatorname{\text{BS}}}
\newcommand{\DP}{\operatorname{\text{DP}}}
\newcommand{\BinD}{\operatorname{\text{Bin}}}
\newcommand{\BinNegD}{\operatorname{\text{BinNeg}}}
\newcommand{\dd}{\mathrm{d}}
\newcommand{\Indic}{\mathbb{I}}
\newcommand{\Borel}{\operatorname{\mathscr{B}}}
\newcommand{\Filtration}{\operatorname{\mathscr{F}}}
\newcommand{\Expec}{\operatorname{\mathbb{E}}}
\newcommand{\Var}{\operatorname{\text{var}}}


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Preliminares {.tabset .tabset-fade .tabset-pills}

> En la `sesion 13` estudiamos que de manera adicional a la informacion/datos de riesgos (datos acerca de la **frecuencia de siniestros** y de las severidades individuales **severidades individuales**), se puede incluir en el modelo informacion acerca de **variables auxiliares intrinsecas** para **diversidicar el riesgo** de un portafolio de seguros.

Asi, si las **variables auxiliares** son de tipo categoricas, de manera que una o combinacion de varias variables adicionales inducen la **segmentacion** del protafolio en $K$ categorias, entonces el portafolio de seguros puede modelarse via **modelos jerarquicos** con $K$-segmentos, i.e.
\begin{eqnarray}
Y_{ik}|k,\theta_k & \sim & F_k(y|\theta_k) \\
\theta_k & \sim & G(\theta|\gamma),
\end{eqnarray}
para $k=1,\ldots,K$ e $i=1,\ldots,I_k$, donde

* $F_k(y|\theta_k)$ es un modelo de probabilidad para el segmento de riesgo $k$, parametrizado por $\theta_k$ (esta distribucion mide la incertidumbre al interior del segmento)

* $G(\theta|\gamma)$ es un modelo de probabilidad para los parametros de todos los segmentos (esta distribucion mide la incertidumbre entre segmentos), a su vez parametrizada por $\gamma$ (parametro comun a todos los segmentos)

* se supone que $\theta_k\neq\theta_l$ para todo $k\neq l$ (para que la especificacion del modelo tenga sentido).

Adicionalmente, se supone que 
$$
\gamma \sim \Pi(\gamma),
$$
cuantifica la informaion suplemental acerca de $\gamma$.

De manera que para todo $i$ y $k$ se tiene que el **modelo marginal**,
$$
P(y|\gamma) = \int F_k(y|\theta_k)G(d \theta_k|\gamma),
$$
es el mismo (por lo que en el agregado, el supuesto de `homogeniedad` se cumple).

> Recodemos que para que esto tenga sentido, la informacion de las variables auxiliares debe inducir que cada poliza pertenezca a uno y solo uno de los segmentos de riesgos distintos.

## Observacion

> En muchas ocasiones, podemos sospechar que al interior del portafolio subyacen diferentes exposiciones al riesgo, pero **no es posible identificar** para una poliza particular a que riesgo corresponde. 

En ese caso, la enumeracion de los $K$ segmentos de riesgo no existe, y la asignacion del tipo de riesgo a cada poliza tampoco es posible de realizar sin error.

En este caso, se recomienda manigestar en el modelo la posibilidad de asociar diferentes segmentos de riesgo para cada poliza empleando **mezclas de modelos**. 

Las mezclas de modelos, quedan especificadas como
$$
Y_{i} \sim F(y|\gamma),
$$
donde 
$$
F(y|\gamma) = \sum_{l=1}^{L}w_l F_l(y|\theta_l),
$$
con

* $F_l(y|\theta_l)$ cuantifica la incertidumbre al interior del **segmento de riesgo no revelado** $l$,

* $(w_1,\ldots,w_L)$ son valores en el simplejo de dimension $(L-1)$, y cuantifican la propension a que una poliza sea asociada con cada uno de los $L$ **segmentos se riesgo no revelados**.

Este modelo puede expresearse _jerarquicamente_ incorporando una **variable de asginacion de segmento** $\iota$ a cada poliza, i.e.
\begin{eqnarray}
Y_i|\iota_i=l &\sim & F_l(y|\theta_l) \\
\iota_i & \sim & \text{Mult}(\iota|w_1,\ldots,w_L),
\end{eqnarray}
para $i=1,\ldots,I$.

> Cuando $L$ es **finito** se dice que se trabaja con modelos de **mezclas finitas**.

## Estimacion

La estimacion de **modelos de mezclas finitas** puede realizase de la siguiente forma:

a. Caso frecuentista, via el `algoritmo EM` (Expectation-Maximization)

b. Caso bayesiano, via el `algoritmo Gibbs sampler`.

> en esta sesion haremos uso del `algoritmo EM`.

## Caso general

> Mas aun, podemos pensar que cada uno de los riesgos asociados con las polizas, $Y_i$ para $i=1,\ldots,I$, puede esyar acompaniado con **informacion adicional revelada**, denotada por $z_i$ (puede ser multidimensional, categorica o numerica escalar), de manera que el modelo de probabilidad para $Y_i$ puede ser **dependiente en z_i**, de manera que 
$$
Y_{i}|z_i \sim F(y|z_i,\gamma),
$$
donde 
$$
F(y|z_i,\gamma) = \sum_{l=1}^{L}w_l F_l(y|z_i,\theta_l),
$$
con

* $F_l(y|z_i,\theta_l)$ cuantifica la incertidumbre al interior del **segmento de riesgo no revelado** $l$, indizada por $z_i$ (como un modelo de regresion, por ejemplo)

* $(w_1,\ldots,w_L)$ son valores en el simplejo de dimension $(L-1)$, y cuantifican la propension a que una poliza sea asociada con cada uno de los $L$ **segmentos se riesgo no revelados**.

> Estos modelos se conocen como **modelos de mezclas finitas de regresion**.

A continuacion veremos como implementar estos modelos en diferentes contextos.

# Mezclas de regresion binomial  {.tabset .tabset-fade .tabset-pills}

```{r}
set.seed(2807)
library("flexmix")

data("NregFix", package = "flexmix")

Model <- FLXMRglm(~ x2 + x1)

fittedModel <- stepFlexmix(y ~ 1, model = Model, nrep = 3, k = 3,
                           data = NregFix, concomitant = FLXPmultinom(~ w))

fittedModel <- relabel(fittedModel, "model", "x1")

summary(refit(fittedModel))

Model2 <- FLXMRglmfix(fixed = ~ x2, nested = list(k = c(1, 2),
                                                  formula = c(~ 0, ~ x1)), varFix = TRUE)

fittedModel2 <- flexmix(y ~ 1, model = Model2,
                        cluster = posterior(fittedModel), data = NregFix,
                        concomitant = FLXPmultinom(~ w))

BIC(fittedModel)

BIC(fittedModel2)
summary(refit(fittedModel2))

```

```{r}
if(!require("flexmix")){install.packages("flexmix")}
library("flexmix")

data("NPreg", package = "flexmix")
## mixture of two linear regression models. Note that control parameters
## can be specified as named list and abbreviated if unique.
ex1 <- flexmix(yn ~ x + I(x^2), data = NPreg, k = 2,
control = list(verb = 5, iter = 100))
ex1
summary(ex1)
plot(ex1)
## now we fit a model with one Gaussian response and one Poisson
## response. Note that the formulas inside the call to FLXMRglm are
## relative to the overall model formula.
ex2 <- flexmix(yn ~ x, data = NPreg, k = 2,
model = list(FLXMRglm(yn ~ . + I(x^2)),
FLXMRglm(yp ~ ., family = "poisson")))
plot(ex2)
ex2
table(ex2@cluster, NPreg$class)
## for Gaussian responses we get coefficients and standard deviation
parameters(ex2, component = 1, model = 1)
## for Poisson response we get only coefficients
parameters(ex2, component = 1, model = 2)
## fitting a model only to the Poisson response is of course
## done like this
ex3 <- flexmix(yp ~ x, data = NPreg, k = 2,
model = FLXMRglm(family = "poisson"))
## if observations are grouped, i.e., we have several observations per
## individual, fitting is usually much faster:
ex4 <- flexmix(yp~x|id1, data = NPreg, k = 2,
model = FLXMRglm(family = "poisson"))## And now a binomial example. Mixtures of binomials are not genericall## identified, here the grouping variable is necessary:set.seed(1234)ex5 <- initFlexmix(cbind(yb,1 - yb) ~ x, data = NPreg, k = 2,model = FLXMRglm(family = "binomial"), nrep = 5)table(NPreg$class, clusters(ex5))ex6 <- initFlexmix(cbind(yb, 1 - yb) ~ x | id2, data = NPreg, k = 2,model = FLXMRglm(family = "binomial"), nrep = 5)table(NPreg$class, clusters(ex6
```

# Mezclas de regresion Poisson  {.tabset .tabset-fade .tabset-pills}

```{r}
data("fabricfault", package = "flexmix")

fabricMix <- stepFlexmix(Faults ~ 1, model = FLXMRglmfix(family="poisson",
                                                         fixed = ~ log(Length)), data = fabricfault, k = 2, nrep = 3)
summary(fabricMix)

summary(refit(fabricMix))

Lnew <- seq(0, 1000, by = 50)

fabricMix.pred <- predict(fabricMix, newdata = data.frame(Length = Lnew))

fabricMix2 <- flexmix(Faults ~ 0, data = fabricfault,
                      cluster = posterior(fabricMix),
                      model = FLXMRglmfix(family = "poisson", fixed = ~ log(Length),
                                          nested = list(k=c(1,1), formula=list(~0,~1))))

summary(refit(fabricMix2))

fabricMix2.pred <-  fabricMix2.pred <- predict(fabricMix2,
                                               newdata = data.frame(Length = Lnew))
```

# Mezclas de regresion beta  {.tabset .tabset-fade .tabset-pills}

```{r}
data("betablocker", package = "flexmix")

betaGlm <- glm(cbind(Deaths, Total - Deaths) ~ Treatment,
               family = "binomial", data = betablocker)

betaGlm

betaMixFix <- stepFlexmix(cbind(Deaths, Total - Deaths) ~ 1 | Center,
                          model = FLXMRglmfix(family = "binomial", fixed = ~ Treatment),
                          k = 2:4, nrep = 3, data = betablocker)

betaMixFix

betaMix <- stepFlexmix(cbind(Deaths, Total - Deaths) ~ Treatment | Center,
                       model = FLXMRglm(family = "binomial"), k = 3, nrep = 3,
                       data = betablocker)

summary(betaMix)

# print(plot(betaMixFix_3, mark = 1, col = "grey", markcol = 1))

parameters(betaMix)

table(clusters(betaMix))

predict(betaMix, newdata = data.frame(Treatment = c("Control", "Treated")))
```

# Lecturas complementarias  {.tabset .tabset-fade .tabset-pills}

* Frühwirth-Schnatter, Sylvia, *Finite Mixture and Markov Switching Models*, Springer 2006.